import math, random

particlesNumber = 2
squareSideLength = 10
maxStartingSpeed = 3
epsilon = 1.77 #Xe
sigma = 4.1 #Xe
maxRay = 2.5 * sigma
universe = []  # List of particles x, y coordinates
speedList = []  # List of particle's speed correlated to universe
timeStep = 0.01
steps = 300

file = open("Lennard-Jones_2D_particles.xyz", "wt")  # Create or overwrites a file
file.write("%s \n\n" % particlesNumber)  # First line of xyz file

for particle in range(particlesNumber):  # This will generate x and y coordinates for each and also speed vectors
    particleCoord = []
    particleCoord.append(random.uniform(- squareSideLength / 2, squareSideLength / 2))
    particleCoord.append(random.uniform(- squareSideLength / 2, squareSideLength / 2))
    particleSpeed = []
    particleSpeed.append(random.uniform(-maxStartingSpeed, maxStartingSpeed))
    particleSpeed.append(random.uniform(-maxStartingSpeed, maxStartingSpeed))
    universe.append(particleCoord)
    speedList.append(particleSpeed)
    file.write("O       %s      %s      0.00000\n" % (universe[particle][0], universe[particle][1]))

for step in range(steps):

    file.write("%s \n\n" % particlesNumber)  # First line of xyz file

    for p1 in range(len(universe)):  # Check if there can be interaction between particles if so it applies the LJ
        for p2 in range(p1 + 1, particlesNumber):
            distance = math.sqrt((universe[p1][0] - universe[p2][0]) ** 2 + (universe[p1][1] - universe[p2][1]) ** 2)
            if distance < maxRay:
                Ftot = - 24 * epsilon * (sigma ** 6) / (distance ** 7) + 48 * epsilon * (sigma ** 12) / (distance ** 13)
                deltaX = abs(universe[p1][0] - universe[p2][0])
                deltaY = abs(universe[p1][1] - universe[p2][1])
                angle = 0
                if universe[p1][0] < universe[p2][0] and universe[p1][1] < universe[p2][1]:  # p2 is in first quadrant
                    angle = math.acos(deltaX / distance)
                elif universe[p1][0] > universe[p2][0] and universe[p1][1] < universe[p2][1]:  # p2 is in second quadrant
                    angle = math.pi - math.acos(deltaX / distance)
                elif universe[p1][0] > universe[p2][0] and universe[p1][1] > universe[p2][1]:  # p2 is in third quadrant
                    angle = math.pi + math.acos(deltaX / distance)
                elif universe[p1][0] < universe[p2][0] and universe[p1][1] > universe[p2][1]: # p2 is in fourth quadrant
                    angle = 2 * math.pi - math.acos(deltaX / distance)

                Fx = Ftot * math.cos(angle)
                Fy = Ftot * math.sin(angle)
                speedList[p1][0] += Fx * timeStep
                speedList[p1][1] += Fy * timeStep
                speedList[p2][0] += - Fx * timeStep
                speedList[p2][1] += - Fy * timeStep
                print(p1, p2)
                print(Ftot)
                print(distance)
                print(speedList[p1])
        universe[p1][0] += speedList[p1][0] * timeStep
        universe[p1][1] += speedList[p1][1] * timeStep

        # if universe[p1][0] > squareSideLength / 2 #Keeps particles in the square
        #  universe[p1][0] -= squareSideLength
        # if universe[p1][1] > squareSideLength / 2
        #  universe[p1][1] -= squareSideLength

        file.write("O       %s      %s      0.00000\n" % (universe[p1][0], universe[p1][1]))
