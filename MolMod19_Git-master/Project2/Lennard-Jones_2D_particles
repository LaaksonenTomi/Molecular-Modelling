import math, random

particlesNumber = 10
squareSideLength = 30
maxStartingSpeed = 5
epsilon = 1.77
sigma = 4.2
maxRay = 2.5 * sigma
universe = [] #List of particles x, y coordinates
speedList = [] #List of particle's speed correlated to universe
TimeStep = 1
Steps = 10

for particle in range(particlesNumber): #This will generate x and y coordinates for each and also speed vectors
  particleCoord = []
  particleCoord.append(random.random(0, squareSideLength))
  particleCoord.append(random.random(0, squareSideLength))
  particleSpeed = []
  particleSpeed.append(random.random(0, maxStartingSpeed))
  particleSpeed.append(random.random(0, maxStartingSpeed))
  universe.append(particleCoord)
  speedList.append(particleSpeed)

for p1 in range(len(universe)): #Check if there can be interaction between particles if so it applies the LJ
  for p2 in range(p1+1, particlesNumber)
    distance = math.sqrt((universe[p1][0] - universe[p2][0]) ** 2 + (universe[p1][1] - universe[p2][1]) ** 2)
    if distance < maxRa
      Ftot = 24 * (epsilon ** 6) / (distance ** 7) - 48 * (epsilon ** 12) / (distance ** 13)
      deltaX = abs(universe[p1][0]-universe[p2][0])
      deltaY = abs(universe[p1][1]-universe[p2][1])
      
      if universe[p1][0] < universe[p2][0] and universe[p1][1] < universe[p2][1]: #p2 is in first quadrant
        angle = math.acos(deltaX / distance)
      elif universe[p1][0] > universe[p2][0] and universe[p1][1] < universe[p2][1]: #p2 is in second quadrant
        angle = math.pi - math.acos(deltaX / distance)
      elif universe[p1][0] > universe[p2][0] and universe[p1][1] > universe[p2][1] #p2 is in third quadrant
        angle = math.pi + math.acos(deltaX / distance)
      elif universe[p1][0] < universe[p2][0] and universe[p1][1] > universe[p2][1] #p2 is in fourth quadrant
        angle = 2 * math.pi - math.acos(deltaX / distance)
      
      Fx = Ftot * math.cos(angle)
      Fy = Ftot * math.sin(angle)
      speedList[p1][0] += Fx * timeStep ** 2
      speedList[p1][1] += Fy * timeStep ** 2
      speedlist[p2][0] += - Fx * timeStep ** 2
      speedlist[p2][1] += - Fy * timeStep ** 2
    
